{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "magicNumber": 1635018093,
    "metadata": {
      "v13": {
        "modules": [
          {
            "name": "System",
            "storage": {
              "prefix": "System",
              "items": [
                {
                  "name": "Account",
                  "modifier": "Default",
                  "type": {
                    "map": {
                      "hasher": "Blake2_128Concat",
                      "key": "AccountId",
                      "value": "AccountInfo",
                      "linked": false
                    }
                  },
                  "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
                  "docs": [
                    " The full account information for a particular account ID."
                  ]
                },
                {
                  "name": "ExtrinsicCount",
                  "modifier": "Optional",
                  "type": { "plain": "u32" },
                  "fallback": "0x00",
                  "docs": [" Total extrinsics count for the current block."]
                },
                {
                  "name": "BlockWeight",
                  "modifier": "Default",
                  "type": { "plain": "ConsumedWeight" },
                  "fallback": "0x000000000000000000000000000000000000000000000000",
                  "docs": [" The current weight for the block."]
                },
                {
                  "name": "AllExtrinsicsLen",
                  "modifier": "Optional",
                  "type": { "plain": "u32" },
                  "fallback": "0x00",
                  "docs": [
                    " Total length (in bytes) for all extrinsics put together, for the current block."
                  ]
                },
                {
                  "name": "BlockHash",
                  "modifier": "Default",
                  "type": {
                    "map": {
                      "hasher": "Twox64Concat",
                      "key": "BlockNumber",
                      "value": "Hash",
                      "linked": false
                    }
                  },
                  "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
                  "docs": [" Map of block numbers to block hashes."]
                },
                {
                  "name": "ExtrinsicData",
                  "modifier": "Default",
                  "type": {
                    "map": {
                      "hasher": "Twox64Concat",
                      "key": "u32",
                      "value": "Bytes",
                      "linked": false
                    }
                  },
                  "fallback": "0x00",
                  "docs": [
                    " Extrinsics data for the current block (maps an extrinsic's index to its data)."
                  ]
                },
                {
                  "name": "Number",
                  "modifier": "Default",
                  "type": { "plain": "BlockNumber" },
                  "fallback": "0x00000000",
                  "docs": [
                    " The current block number being processed. Set by `execute_block`."
                  ]
                },
                {
                  "name": "ParentHash",
                  "modifier": "Default",
                  "type": { "plain": "Hash" },
                  "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
                  "docs": [" Hash of the previous block."]
                },
                {
                  "name": "Digest",
                  "modifier": "Default",
                  "type": { "plain": "DigestOf" },
                  "fallback": "0x00",
                  "docs": [
                    " Digest of the current block, also part of the block header."
                  ]
                },
                {
                  "name": "Events",
                  "modifier": "Default",
                  "type": { "plain": "Vec<EventRecord>" },
                  "fallback": "0x00",
                  "docs": [" Events deposited for the current block."]
                },
                {
                  "name": "EventCount",
                  "modifier": "Default",
                  "type": { "plain": "EventIndex" },
                  "fallback": "0x00000000",
                  "docs": [" The number of events in the `Events<T>` list."]
                },
                {
                  "name": "EventTopics",
                  "modifier": "Default",
                  "type": {
                    "map": {
                      "hasher": "Blake2_128Concat",
                      "key": "Hash",
                      "value": "Vec<(BlockNumber,EventIndex)>",
                      "linked": false
                    }
                  },
                  "fallback": "0x00",
                  "docs": [
                    " Mapping between a topic (represented by T::Hash) and a vector of indexes",
                    " of events in the `<Events<T>>` list.",
                    "",
                    " All topic vectors have deterministic storage locations depending on the topic. This",
                    " allows light-clients to leverage the changes trie storage tracking mechanism and",
                    " in case of changes fetch the list of events of interest.",
                    "",
                    " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just",
                    " the `EventIndex` then in case if the topic has the same contents on the next block",
                    " no notification will be triggered thus the event might be lost."
                  ]
                },
                {
                  "name": "LastRuntimeUpgrade",
                  "modifier": "Optional",
                  "type": { "plain": "LastRuntimeUpgradeInfo" },
                  "fallback": "0x00",
                  "docs": [
                    " Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened."
                  ]
                },
                {
                  "name": "UpgradedToU32RefCount",
                  "modifier": "Default",
                  "type": { "plain": "bool" },
                  "fallback": "0x00",
                  "docs": [
                    " True if we have upgraded so that `type RefCount` is `u32`. False (default) if not."
                  ]
                },
                {
                  "name": "UpgradedToTripleRefCount",
                  "modifier": "Default",
                  "type": { "plain": "bool" },
                  "fallback": "0x00",
                  "docs": [
                    " True if we have upgraded so that AccountInfo contains three types of `RefCount`. False",
                    " (default) if not."
                  ]
                },
                {
                  "name": "ExecutionPhase",
                  "modifier": "Optional",
                  "type": { "plain": "Phase" },
                  "fallback": "0x00",
                  "docs": [" The execution phase of the block."]
                }
              ]
            },
            "calls": [
              {
                "name": "fill_block",
                "args": [{ "name": "_ratio", "type": "Perbill" }],
                "docs": [
                  " A dispatch that will fill the block weight up to the given ratio."
                ]
              },
              {
                "name": "remark",
                "args": [{ "name": "_remark", "type": "Bytes" }],
                "docs": [
                  " Make some on-chain remark.",
                  "",
                  " # <weight>",
                  " - `O(1)`",
                  " # </weight>"
                ]
              },
              {
                "name": "set_heap_pages",
                "args": [{ "name": "pages", "type": "u64" }],
                "docs": [
                  " Set the number of pages in the WebAssembly environment's heap.",
                  "",
                  " # <weight>",
                  " - `O(1)`",
                  " - 1 storage write.",
                  " - Base Weight: 1.405 µs",
                  " - 1 write to HEAP_PAGES",
                  " # </weight>"
                ]
              },
              {
                "name": "set_code",
                "args": [{ "name": "code", "type": "Bytes" }],
                "docs": [
                  " Set the new runtime code.",
                  "",
                  " # <weight>",
                  " - `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`",
                  " - 1 storage write (codec `O(C)`).",
                  " - 1 call to `can_set_code`: `O(S)` (calls `sp_io::misc::runtime_version` which is expensive).",
                  " - 1 event.",
                  " The weight of this function is dependent on the runtime, but generally this is very expensive.",
                  " We will treat this as a full block.",
                  " # </weight>"
                ]
              },
              {
                "name": "set_code_without_checks",
                "args": [{ "name": "code", "type": "Bytes" }],
                "docs": [
                  " Set the new runtime code without doing any checks of the given `code`.",
                  "",
                  " # <weight>",
                  " - `O(C)` where `C` length of `code`",
                  " - 1 storage write (codec `O(C)`).",
                  " - 1 event.",
                  " The weight of this function is dependent on the runtime. We will treat this as a full block.",
                  " # </weight>"
                ]
              },
              {
                "name": "set_changes_trie_config",
                "args": [
                  {
                    "name": "changes_trie_config",
                    "type": "Option<ChangesTrieConfiguration>"
                  }
                ],
                "docs": [
                  " Set the new changes trie configuration.",
                  "",
                  " # <weight>",
                  " - `O(1)`",
                  " - 1 storage write or delete (codec `O(1)`).",
                  " - 1 call to `deposit_log`: Uses `append` API, so O(1)",
                  " - Base Weight: 7.218 µs",
                  " - DB Weight:",
                  "     - Writes: Changes Trie, System Digest",
                  " # </weight>"
                ]
              },
              {
                "name": "set_storage",
                "args": [{ "name": "items", "type": "Vec<KeyValue>" }],
                "docs": [
                  " Set some items of storage.",
                  "",
                  " # <weight>",
                  " - `O(I)` where `I` length of `items`",
                  " - `I` storage writes (`O(1)`).",
                  " - Base Weight: 0.568 * i µs",
                  " - Writes: Number of items",
                  " # </weight>"
                ]
              },
              {
                "name": "kill_storage",
                "args": [{ "name": "keys", "type": "Vec<Key>" }],
                "docs": [
                  " Kill some items from storage.",
                  "",
                  " # <weight>",
                  " - `O(IK)` where `I` length of `keys` and `K` length of one key",
                  " - `I` storage deletions.",
                  " - Base Weight: .378 * i µs",
                  " - Writes: Number of items",
                  " # </weight>"
                ]
              },
              {
                "name": "kill_prefix",
                "args": [
                  { "name": "prefix", "type": "Key" },
                  { "name": "_subkeys", "type": "u32" }
                ],
                "docs": [
                  " Kill all storage items with a key that starts with the given prefix.",
                  "",
                  " **NOTE:** We rely on the Root origin to provide us the number of subkeys under",
                  " the prefix we are removing to accurately calculate the weight of this function.",
                  "",
                  " # <weight>",
                  " - `O(P)` where `P` amount of keys with prefix `prefix`",
                  " - `P` storage deletions.",
                  " - Base Weight: 0.834 * P µs",
                  " - Writes: Number of subkeys + 1",
                  " # </weight>"
                ]
              },
              {
                "name": "remark_with_event",
                "args": [{ "name": "remark", "type": "Bytes" }],
                "docs": [
                  " Make some on-chain remark and emit event.",
                  "",
                  " # <weight>",
                  " - `O(b)` where b is the length of the remark.",
                  " - 1 event.",
                  " # </weight>"
                ]
              }
            ],
            "events": [
              {
                "name": "ExtrinsicSuccess",
                "args": ["DispatchInfo"],
                "docs": [" An extrinsic completed successfully. \\[info\\]"]
              },
              {
                "name": "ExtrinsicFailed",
                "args": ["DispatchError", "DispatchInfo"],
                "docs": [" An extrinsic failed. \\[error, info\\]"]
              },
              {
                "name": "CodeUpdated",
                "args": [],
                "docs": [" `:code` was updated."]
              },
              {
                "name": "NewAccount",
                "args": ["AccountId"],
                "docs": [" A new \\[account\\] was created."]
              },
              {
                "name": "KilledAccount",
                "args": ["AccountId"],
                "docs": [" An \\[account\\] was reaped."]
              },
              {
                "name": "Remarked",
                "args": ["AccountId", "Hash"],
                "docs": [
                  " On on-chain remark happened. \\[origin, remark_hash\\]"
                ]
              }
            ],
            "constants": [
              {
                "name": "BlockWeights",
                "type": "BlockWeights",
                "value": "0x00f2052a0100000000204aa9d1010000405973070000000001c06e96a62e010000010098f73e5d010000010000000000000000405973070000000001c0f6e810a30100000100204aa9d1010000010088526a740000004059730700000000000000",
                "docs": [" Block & extrinsics weights: base values and limits."]
              },
              {
                "name": "BlockLength",
                "type": "BlockLength",
                "value": "0x00003c000000500000005000",
                "docs": [" The maximum length of a block (in bytes)."]
              },
              {
                "name": "BlockHashCount",
                "type": "BlockNumber",
                "value": "0x60090000",
                "docs": [
                  " Maximum number of block number to block hash mappings to keep (oldest pruned first)."
                ]
              },
              {
                "name": "DbWeight",
                "type": "RuntimeDbWeight",
                "value": "0x40787d010000000000e1f50500000000",
                "docs": [
                  " The weight of runtime database operations the runtime can invoke."
                ]
              },
              {
                "name": "Version",
                "type": "RuntimeVersion",
                "value": "0x346e6f64652d74656d706c617465346e6f64652d74656d706c61746501000000640000000100000028df6acb689907609b0300000037e397fc7c91f5e40100000040fe3ad401f8959a05000000d2bc9897eed08f1502000000f78b278be53f454c02000000dd718d5cc53262d401000000ab3c0572291feb8b01000000ed99c5acb25eedf502000000bc9d89904f5b923f0100000037c8bb1350a9a2a80100000001000000",
                "docs": [" Get the chain's current version."]
              },
              {
                "name": "SS58Prefix",
                "type": "u8",
                "value": "0x2a",
                "docs": [
                  " The designated SS85 prefix of this chain.",
                  "",
                  " This replaces the \"ss58Format\" property declared in the chain spec. Reason is",
                  " that the runtime should know about the prefix in order to make use of it as",
                  " an identifier of the chain."
                ]
              }
            ],
            "errors": [
              {
                "name": "InvalidSpecName",
                "docs": [
                  " The name of specification does not match between the current runtime",
                  " and the new runtime."
                ]
              },
              {
                "name": "SpecVersionNeedsToIncrease",
                "docs": [
                  " The specification version is not allowed to decrease between the current runtime",
                  " and the new runtime."
                ]
              },
              {
                "name": "FailedToExtractRuntimeVersion",
                "docs": [
                  " Failed to extract the runtime version from the new runtime.",
                  "",
                  " Either calling `Core_version` or decoding `RuntimeVersion` failed."
                ]
              },
              {
                "name": "NonDefaultComposite",
                "docs": [
                  " Suicide called when the account has non-default composite data."
                ]
              },
              {
                "name": "NonZeroRefCount",
                "docs": [
                  " There is a non-zero reference count preventing the account from being purged."
                ]
              }
            ],
            "index": 0
          },
          {
            "name": "RandomnessCollectiveFlip",
            "storage": {
              "prefix": "RandomnessCollectiveFlip",
              "items": [
                {
                  "name": "RandomMaterial",
                  "modifier": "Default",
                  "type": { "plain": "Vec<Hash>" },
                  "fallback": "0x00",
                  "docs": [
                    " Series of block headers from the last 81 blocks that acts as random seed material. This",
                    " is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of",
                    " the oldest hash."
                  ]
                }
              ]
            },
            "calls": [],
            "events": null,
            "constants": [],
            "errors": [],
            "index": 1
          },
          {
            "name": "Timestamp",
            "storage": {
              "prefix": "Timestamp",
              "items": [
                {
                  "name": "Now",
                  "modifier": "Default",
                  "type": { "plain": "Moment" },
                  "fallback": "0x0000000000000000",
                  "docs": [" Current time for the current block."]
                },
                {
                  "name": "DidUpdate",
                  "modifier": "Default",
                  "type": { "plain": "bool" },
                  "fallback": "0x00",
                  "docs": [" Did the timestamp get updated in this block?"]
                }
              ]
            },
            "calls": [
              {
                "name": "set",
                "args": [{ "name": "now", "type": "Compact<Moment>" }],
                "docs": [
                  " Set the current time.",
                  "",
                  " This call should be invoked exactly once per block. It will panic at the finalization",
                  " phase, if this call hasn't been invoked by that time.",
                  "",
                  " The timestamp should be greater than the previous one by the amount specified by",
                  " `MinimumPeriod`.",
                  "",
                  " The dispatch origin for this call must be `Inherent`.",
                  "",
                  " # <weight>",
                  " - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)",
                  " - 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in `on_finalize`)",
                  " - 1 event handler `on_timestamp_set`. Must be `O(1)`.",
                  " # </weight>"
                ]
              }
            ],
            "events": null,
            "constants": [
              {
                "name": "MinimumPeriod",
                "type": "Moment",
                "value": "0xb80b000000000000",
                "docs": [
                  " The minimum period between blocks. Beware that this is different to the *expected* period",
                  " that the block production apparatus provides. Your chosen consensus system will generally",
                  " work with this to determine a sensible block time. e.g. For Aura, it will be double this",
                  " period on default settings."
                ]
              }
            ],
            "errors": [],
            "index": 2
          },
          {
            "name": "Aura",
            "storage": null,
            "calls": null,
            "events": null,
            "constants": [],
            "errors": [],
            "index": 3
          },
          {
            "name": "Grandpa",
            "storage": {
              "prefix": "Grandpa",
              "items": [
                {
                  "name": "State",
                  "modifier": "Default",
                  "type": { "plain": "StoredState" },
                  "fallback": "0x00",
                  "docs": [" State of the current authority set."]
                },
                {
                  "name": "PendingChange",
                  "modifier": "Optional",
                  "type": { "plain": "StoredPendingChange" },
                  "fallback": "0x00",
                  "docs": [" Pending change: (signaled at, scheduled change)."]
                },
                {
                  "name": "NextForced",
                  "modifier": "Optional",
                  "type": { "plain": "BlockNumber" },
                  "fallback": "0x00",
                  "docs": [" next block number where we can force a change."]
                },
                {
                  "name": "Stalled",
                  "modifier": "Optional",
                  "type": { "plain": "(BlockNumber,BlockNumber)" },
                  "fallback": "0x00",
                  "docs": [" `true` if we are currently stalled."]
                },
                {
                  "name": "CurrentSetId",
                  "modifier": "Default",
                  "type": { "plain": "SetId" },
                  "fallback": "0x0000000000000000",
                  "docs": [
                    " The number of changes (both in terms of keys and underlying economic responsibilities)",
                    " in the \"set\" of Grandpa validators from genesis."
                  ]
                },
                {
                  "name": "SetIdSession",
                  "modifier": "Optional",
                  "type": {
                    "map": {
                      "hasher": "Twox64Concat",
                      "key": "SetId",
                      "value": "SessionIndex",
                      "linked": false
                    }
                  },
                  "fallback": "0x00",
                  "docs": [
                    " A mapping from grandpa set ID to the index of the *most recent* session for which its",
                    " members were responsible.",
                    "",
                    " TWOX-NOTE: `SetId` is not under user control."
                  ]
                }
              ]
            },
            "calls": [
              {
                "name": "report_equivocation",
                "args": [
                  { "name": "equivocation_proof", "type": "EquivocationProof" },
                  { "name": "key_owner_proof", "type": "KeyOwnerProof" }
                ],
                "docs": [
                  " Report voter equivocation/misbehavior. This method will verify the",
                  " equivocation proof and validate the given key ownership proof",
                  " against the extracted offender. If both are valid, the offence",
                  " will be reported."
                ]
              },
              {
                "name": "report_equivocation_unsigned",
                "args": [
                  { "name": "equivocation_proof", "type": "EquivocationProof" },
                  { "name": "key_owner_proof", "type": "KeyOwnerProof" }
                ],
                "docs": [
                  " Report voter equivocation/misbehavior. This method will verify the",
                  " equivocation proof and validate the given key ownership proof",
                  " against the extracted offender. If both are valid, the offence",
                  " will be reported.",
                  "",
                  " This extrinsic must be called unsigned and it is expected that only",
                  " block authors will call it (validated in `ValidateUnsigned`), as such",
                  " if the block author is defined it will be defined as the equivocation",
                  " reporter."
                ]
              },
              {
                "name": "note_stalled",
                "args": [
                  { "name": "delay", "type": "BlockNumber" },
                  {
                    "name": "best_finalized_block_number",
                    "type": "BlockNumber"
                  }
                ],
                "docs": [
                  " Note that the current authority set of the GRANDPA finality gadget has",
                  " stalled. This will trigger a forced authority set change at the beginning",
                  " of the next session, to be enacted `delay` blocks after that. The delay",
                  " should be high enough to safely assume that the block signalling the",
                  " forced change will not be re-orged (e.g. 1000 blocks). The GRANDPA voters",
                  " will start the new authority set using the given finalized block as base.",
                  " Only callable by root."
                ]
              }
            ],
            "events": [
              {
                "name": "NewAuthorities",
                "args": ["AuthorityList"],
                "docs": [
                  " New authority set has been applied. \\[authority_set\\]"
                ]
              },
              {
                "name": "Paused",
                "args": [],
                "docs": [" Current authority set has been paused."]
              },
              {
                "name": "Resumed",
                "args": [],
                "docs": [" Current authority set has been resumed."]
              }
            ],
            "constants": [],
            "errors": [
              {
                "name": "PauseFailed",
                "docs": [
                  " Attempt to signal GRANDPA pause when the authority set isn't live",
                  " (either paused or already pending pause)."
                ]
              },
              {
                "name": "ResumeFailed",
                "docs": [
                  " Attempt to signal GRANDPA resume when the authority set isn't paused",
                  " (either live or already pending resume)."
                ]
              },
              {
                "name": "ChangePending",
                "docs": [
                  " Attempt to signal GRANDPA change with one already pending."
                ]
              },
              {
                "name": "TooSoon",
                "docs": [" Cannot signal forced change so soon after last."]
              },
              {
                "name": "InvalidKeyOwnershipProof",
                "docs": [
                  " A key ownership proof provided as part of an equivocation report is invalid."
                ]
              },
              {
                "name": "InvalidEquivocationProof",
                "docs": [
                  " An equivocation proof provided as part of an equivocation report is invalid."
                ]
              },
              {
                "name": "DuplicateOffenceReport",
                "docs": [
                  " A given equivocation report is valid but already previously reported."
                ]
              }
            ],
            "index": 4
          },
          {
            "name": "Balances",
            "storage": {
              "prefix": "Balances",
              "items": [
                {
                  "name": "TotalIssuance",
                  "modifier": "Default",
                  "type": { "plain": "Balance" },
                  "fallback": "0x00000000000000000000000000000000",
                  "docs": [" The total units issued in the system."]
                },
                {
                  "name": "Account",
                  "modifier": "Default",
                  "type": {
                    "map": {
                      "hasher": "Blake2_128Concat",
                      "key": "AccountId",
                      "value": "AccountData",
                      "linked": false
                    }
                  },
                  "fallback": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
                  "docs": [
                    " The balance of an account.",
                    "",
                    " NOTE: This is only used in the case that this pallet is used to store balances."
                  ]
                },
                {
                  "name": "Locks",
                  "modifier": "Default",
                  "type": {
                    "map": {
                      "hasher": "Blake2_128Concat",
                      "key": "AccountId",
                      "value": "Vec<BalanceLock>",
                      "linked": false
                    }
                  },
                  "fallback": "0x00",
                  "docs": [
                    " Any liquidity locks on some account balances.",
                    " NOTE: Should only be accessed when setting, changing and freeing a lock."
                  ]
                },
                {
                  "name": "StorageVersion",
                  "modifier": "Default",
                  "type": { "plain": "Releases" },
                  "fallback": "0x00",
                  "docs": [
                    " Storage version of the pallet.",
                    "",
                    " This is set to v2.0.0 for new networks."
                  ]
                }
              ]
            },
            "calls": [
              {
                "name": "transfer",
                "args": [
                  { "name": "dest", "type": "LookupSource" },
                  { "name": "value", "type": "Compact<Balance>" }
                ],
                "docs": [
                  " Transfer some liquid free balance to another account.",
                  "",
                  " `transfer` will set the `FreeBalance` of the sender and receiver.",
                  " It will decrease the total issuance of the system by the `TransferFee`.",
                  " If the sender's account is below the existential deposit as a result",
                  " of the transfer, the account will be reaped.",
                  "",
                  " The dispatch origin for this call must be `Signed` by the transactor.",
                  "",
                  " # <weight>",
                  " - Dependent on arguments but not critical, given proper implementations for",
                  "   input config types. See related functions below.",
                  " - It contains a limited number of reads and writes internally and no complex computation.",
                  "",
                  " Related functions:",
                  "",
                  "   - `ensure_can_withdraw` is always called internally but has a bounded complexity.",
                  "   - Transferring balances to accounts that did not exist before will cause",
                  "      `T::OnNewAccount::on_new_account` to be called.",
                  "   - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.",
                  "   - `transfer_keep_alive` works the same way as `transfer`, but has an additional",
                  "     check that the transfer will not kill the origin account.",
                  " ---------------------------------",
                  " - Base Weight: 73.64 µs, worst case scenario (account created, account removed)",
                  " - DB Weight: 1 Read and 1 Write to destination account",
                  " - Origin account is already in memory, so no DB operations for them.",
                  " # </weight>"
                ]
              },
              {
                "name": "set_balance",
                "args": [
                  { "name": "who", "type": "LookupSource" },
                  { "name": "new_free", "type": "Compact<Balance>" },
                  { "name": "new_reserved", "type": "Compact<Balance>" }
                ],
                "docs": [
                  " Set the balances of a given account.",
                  "",
                  " This will alter `FreeBalance` and `ReservedBalance` in storage. it will",
                  " also decrease the total issuance of the system (`TotalIssuance`).",
                  " If the new free or reserved balance is below the existential deposit,",
                  " it will reset the account nonce (`frame_system::AccountNonce`).",
                  "",
                  " The dispatch origin for this call is `root`.",
                  "",
                  " # <weight>",
                  " - Independent of the arguments.",
                  " - Contains a limited number of reads and writes.",
                  " ---------------------",
                  " - Base Weight:",
                  "     - Creating: 27.56 µs",
                  "     - Killing: 35.11 µs",
                  " - DB Weight: 1 Read, 1 Write to `who`",
                  " # </weight>"
                ]
              },
              {
                "name": "force_transfer",
                "args": [
                  { "name": "source", "type": "LookupSource" },
                  { "name": "dest", "type": "LookupSource" },
                  { "name": "value", "type": "Compact<Balance>" }
                ],
                "docs": [
                  " Exactly as `transfer`, except the origin must be root and the source account may be",
                  " specified.",
                  " # <weight>",
                  " - Same as transfer, but additional read and write because the source account is",
                  "   not assumed to be in the overlay.",
                  " # </weight>"
                ]
              },
              {
                "name": "transfer_keep_alive",
                "args": [
                  { "name": "dest", "type": "LookupSource" },
                  { "name": "value", "type": "Compact<Balance>" }
                ],
                "docs": [
                  " Same as the [`transfer`] call, but with a check that the transfer will not kill the",
                  " origin account.",
                  "",
                  " 99% of the time you want [`transfer`] instead.",
                  "",
                  " [`transfer`]: struct.Pallet.html#method.transfer",
                  " # <weight>",
                  " - Cheaper than transfer because account cannot be killed.",
                  " - Base Weight: 51.4 µs",
                  " - DB Weight: 1 Read and 1 Write to dest (sender is in overlay already)",
                  " #</weight>"
                ]
              }
            ],
            "events": [
              {
                "name": "Endowed",
                "args": ["AccountId", "Balance"],
                "docs": [
                  " An account was created with some free balance. \\[account, free_balance\\]"
                ]
              },
              {
                "name": "DustLost",
                "args": ["AccountId", "Balance"],
                "docs": [
                  " An account was removed whose balance was non-zero but below ExistentialDeposit,",
                  " resulting in an outright loss. \\[account, balance\\]"
                ]
              },
              {
                "name": "Transfer",
                "args": ["AccountId", "AccountId", "Balance"],
                "docs": [" Transfer succeeded. \\[from, to, value\\]"]
              },
              {
                "name": "BalanceSet",
                "args": ["AccountId", "Balance", "Balance"],
                "docs": [
                  " A balance was set by root. \\[who, free, reserved\\]"
                ]
              },
              {
                "name": "Deposit",
                "args": ["AccountId", "Balance"],
                "docs": [
                  " Some amount was deposited (e.g. for transaction fees). \\[who, deposit\\]"
                ]
              },
              {
                "name": "Reserved",
                "args": ["AccountId", "Balance"],
                "docs": [
                  " Some balance was reserved (moved from free to reserved). \\[who, value\\]"
                ]
              },
              {
                "name": "Unreserved",
                "args": ["AccountId", "Balance"],
                "docs": [
                  " Some balance was unreserved (moved from reserved to free). \\[who, value\\]"
                ]
              },
              {
                "name": "ReserveRepatriated",
                "args": ["AccountId", "AccountId", "Balance", "Status"],
                "docs": [
                  " Some balance was moved from the reserve of the first account to the second account.",
                  " Final argument indicates the destination balance type.",
                  " \\[from, to, balance, destination_status\\]"
                ]
              }
            ],
            "constants": [
              {
                "name": "ExistentialDeposit",
                "type": "Balance",
                "value": "0xf4010000000000000000000000000000",
                "docs": [
                  " The minimum amount required to keep an account open."
                ]
              }
            ],
            "errors": [
              {
                "name": "VestingBalance",
                "docs": [" Vesting balance too high to send value"]
              },
              {
                "name": "LiquidityRestrictions",
                "docs": [" Account liquidity restrictions prevent withdrawal"]
              },
              {
                "name": "InsufficientBalance",
                "docs": [" Balance too low to send value"]
              },
              {
                "name": "ExistentialDeposit",
                "docs": [
                  " Value too low to create account due to existential deposit"
                ]
              },
              {
                "name": "KeepAlive",
                "docs": [" Transfer/payment would kill account"]
              },
              {
                "name": "ExistingVestingSchedule",
                "docs": [" A vesting schedule already exists for this account"]
              },
              {
                "name": "DeadAccount",
                "docs": [" Beneficiary account must pre-exist"]
              }
            ],
            "index": 5
          },
          {
            "name": "TransactionPayment",
            "storage": {
              "prefix": "TransactionPayment",
              "items": [
                {
                  "name": "NextFeeMultiplier",
                  "modifier": "Default",
                  "type": { "plain": "Multiplier" },
                  "fallback": "0x000064a7b3b6e00d0000000000000000",
                  "docs": []
                },
                {
                  "name": "StorageVersion",
                  "modifier": "Default",
                  "type": { "plain": "Releases" },
                  "fallback": "0x00",
                  "docs": []
                }
              ]
            },
            "calls": null,
            "events": null,
            "constants": [
              {
                "name": "TransactionByteFee",
                "type": "BalanceOf",
                "value": "0x01000000000000000000000000000000",
                "docs": [
                  " The fee to be paid for making a transaction; the per-byte portion."
                ]
              },
              {
                "name": "WeightToFee",
                "type": "Vec<WeightToFeeCoefficient>",
                "value": "0x0401000000000000000000000000000000000000000001",
                "docs": [
                  " The polynomial that is applied in order to derive fee from weight."
                ]
              }
            ],
            "errors": [],
            "index": 6
          },
          {
            "name": "Sudo",
            "storage": {
              "prefix": "Sudo",
              "items": [
                {
                  "name": "Key",
                  "modifier": "Default",
                  "type": { "plain": "AccountId" },
                  "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
                  "docs": [" The `AccountId` of the sudo key."]
                }
              ]
            },
            "calls": [
              {
                "name": "sudo",
                "args": [{ "name": "call", "type": "Call" }],
                "docs": [
                  " Authenticates the sudo key and dispatches a function call with `Root` origin.",
                  "",
                  " The dispatch origin for this call must be _Signed_.",
                  "",
                  " # <weight>",
                  " - O(1).",
                  " - Limited storage reads.",
                  " - One DB write (event).",
                  " - Weight of derivative `call` execution + 10,000.",
                  " # </weight>"
                ]
              },
              {
                "name": "sudo_unchecked_weight",
                "args": [
                  { "name": "call", "type": "Call" },
                  { "name": "_weight", "type": "Weight" }
                ],
                "docs": [
                  " Authenticates the sudo key and dispatches a function call with `Root` origin.",
                  " This function does not check the weight of the call, and instead allows the",
                  " Sudo user to specify the weight of the call.",
                  "",
                  " The dispatch origin for this call must be _Signed_.",
                  "",
                  " # <weight>",
                  " - O(1).",
                  " - The weight of this call is defined by the caller.",
                  " # </weight>"
                ]
              },
              {
                "name": "set_key",
                "args": [{ "name": "new", "type": "LookupSource" }],
                "docs": [
                  " Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key.",
                  "",
                  " The dispatch origin for this call must be _Signed_.",
                  "",
                  " # <weight>",
                  " - O(1).",
                  " - Limited storage reads.",
                  " - One DB change.",
                  " # </weight>"
                ]
              },
              {
                "name": "sudo_as",
                "args": [
                  { "name": "who", "type": "LookupSource" },
                  { "name": "call", "type": "Call" }
                ],
                "docs": [
                  " Authenticates the sudo key and dispatches a function call with `Signed` origin from",
                  " a given account.",
                  "",
                  " The dispatch origin for this call must be _Signed_.",
                  "",
                  " # <weight>",
                  " - O(1).",
                  " - Limited storage reads.",
                  " - One DB write (event).",
                  " - Weight of derivative `call` execution + 10,000.",
                  " # </weight>"
                ]
              }
            ],
            "events": [
              {
                "name": "Sudid",
                "args": ["DispatchResult"],
                "docs": [" A sudo just took place. \\[result\\]"]
              },
              {
                "name": "KeyChanged",
                "args": ["AccountId"],
                "docs": [
                  " The \\[sudoer\\] just switched identity; the old key is supplied."
                ]
              },
              {
                "name": "SudoAsDone",
                "args": ["DispatchResult"],
                "docs": [" A sudo just took place. \\[result\\]"]
              }
            ],
            "constants": [],
            "errors": [
              {
                "name": "RequireSudo",
                "docs": [" Sender must be the Sudo account"]
              }
            ],
            "index": 7
          },
          {
            "name": "Utility",
            "storage": { "prefix": "Utility", "items": [] },
            "calls": [
              {
                "name": "batch",
                "args": [{ "name": "calls", "type": "Vec<Call>" }],
                "docs": [
                  " Send a batch of dispatch calls.",
                  "",
                  " May be called from any origin.",
                  "",
                  " - `calls`: The calls to be dispatched from the same origin.",
                  "",
                  " If origin is root then call are dispatch without checking origin filter. (This includes",
                  " bypassing `frame_system::Config::BaseCallFilter`).",
                  "",
                  " # <weight>",
                  " - Complexity: O(C) where C is the number of calls to be batched.",
                  " # </weight>",
                  "",
                  " This will return `Ok` in all circumstances. To determine the success of the batch, an",
                  " event is deposited. If a call failed and the batch was interrupted, then the",
                  " `BatchInterrupted` event is deposited, along with the number of successful calls made",
                  " and the error of the failed call. If all were successful, then the `BatchCompleted`",
                  " event is deposited."
                ]
              },
              {
                "name": "as_derivative",
                "args": [
                  { "name": "index", "type": "u16" },
                  { "name": "call", "type": "Call" }
                ],
                "docs": [
                  " Send a call through an indexed pseudonym of the sender.",
                  "",
                  " Filter from origin are passed along. The call will be dispatched with an origin which",
                  " use the same filter as the origin of this call.",
                  "",
                  " NOTE: If you need to ensure that any account-based filtering is not honored (i.e.",
                  " because you expect `proxy` to have been used prior in the call stack and you do not want",
                  " the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`",
                  " in the Multisig pallet instead.",
                  "",
                  " NOTE: Prior to version *12, this was called `as_limited_sub`.",
                  "",
                  " The dispatch origin for this call must be _Signed_."
                ]
              },
              {
                "name": "batch_all",
                "args": [{ "name": "calls", "type": "Vec<Call>" }],
                "docs": [
                  " Send a batch of dispatch calls and atomically execute them.",
                  " The whole transaction will rollback and fail if any of the calls failed.",
                  "",
                  " May be called from any origin.",
                  "",
                  " - `calls`: The calls to be dispatched from the same origin.",
                  "",
                  " If origin is root then call are dispatch without checking origin filter. (This includes",
                  " bypassing `frame_system::Config::BaseCallFilter`).",
                  "",
                  " # <weight>",
                  " - Complexity: O(C) where C is the number of calls to be batched.",
                  " # </weight>"
                ]
              }
            ],
            "events": [
              {
                "name": "BatchInterrupted",
                "args": ["u32", "DispatchError"],
                "docs": [
                  " Batch of dispatches did not complete fully. Index of first failing dispatch given, as",
                  " well as the error. \\[index, error\\]"
                ]
              },
              {
                "name": "BatchCompleted",
                "args": [],
                "docs": [" Batch of dispatches completed fully with no error."]
              }
            ],
            "constants": [],
            "errors": [],
            "index": 8
          },
          {
            "name": "Authorship",
            "storage": {
              "prefix": "Authorship",
              "items": [
                {
                  "name": "Uncles",
                  "modifier": "Default",
                  "type": { "plain": "Vec<UncleEntryItem>" },
                  "fallback": "0x00",
                  "docs": [" Uncles"]
                },
                {
                  "name": "Author",
                  "modifier": "Optional",
                  "type": { "plain": "AccountId" },
                  "fallback": "0x00",
                  "docs": [" Author of current block."]
                },
                {
                  "name": "DidSetUncles",
                  "modifier": "Default",
                  "type": { "plain": "bool" },
                  "fallback": "0x00",
                  "docs": [" Whether uncles were already set in this block."]
                }
              ]
            },
            "calls": null,
            "events": null,
            "constants": [],
            "errors": [
              {
                "name": "InvalidUncleParent",
                "docs": [" The uncle parent not in the chain."]
              },
              {
                "name": "UnclesAlreadySet",
                "docs": [" Uncles already set in the block."]
              },
              { "name": "TooManyUncles", "docs": [" Too many uncles."] },
              { "name": "GenesisUncle", "docs": [" The uncle is genesis."] },
              {
                "name": "TooHighUncle",
                "docs": [" The uncle is too high in chain."]
              },
              {
                "name": "UncleAlreadyIncluded",
                "docs": [" The uncle is already included."]
              },
              {
                "name": "OldUncle",
                "docs": [" The uncle isn't recent enough to be included."]
              }
            ],
            "index": 9
          },
          {
            "name": "Gear",
            "storage": {
              "prefix": "Gear",
              "items": [
                {
                  "name": "MessageQueue",
                  "modifier": "Optional",
                  "type": { "plain": "Vec<IntermediateMessage>" },
                  "fallback": "0x00",
                  "docs": []
                },
                {
                  "name": "DequeueLimit",
                  "modifier": "Optional",
                  "type": { "plain": "u32" },
                  "fallback": "0x00",
                  "docs": []
                },
                {
                  "name": "MessagesProcessed",
                  "modifier": "Default",
                  "type": { "plain": "u32" },
                  "fallback": "0x00000000",
                  "docs": []
                }
              ]
            },
            "calls": [
              {
                "name": "submit_program",
                "args": [
                  { "name": "code", "type": "Bytes" },
                  { "name": "salt", "type": "Bytes" },
                  { "name": "init_payload", "type": "Bytes" },
                  { "name": "gas_limit", "type": "u64" },
                  { "name": "value", "type": "BalanceOf" }
                ],
                "docs": []
              },
              {
                "name": "send_message",
                "args": [
                  { "name": "destination", "type": "H256" },
                  { "name": "payload", "type": "Bytes" },
                  { "name": "gas_limit", "type": "u64" },
                  { "name": "value", "type": "BalanceOf" }
                ],
                "docs": []
              },
              { "name": "process_queue", "args": [], "docs": [] }
            ],
            "events": [
              {
                "name": "Log",
                "args": ["Message"],
                "docs": [" Log event from the specific program."]
              },
              {
                "name": "NewProgram",
                "args": ["H256"],
                "docs": [" Program created in the network."]
              },
              {
                "name": "InitFailure",
                "args": ["H256", "MessageError"],
                "docs": [" Program initialization error."]
              },
              {
                "name": "ProgramInitialized",
                "args": ["H256"],
                "docs": [" Program initialized."]
              },
              {
                "name": "MessagesDequeued",
                "args": ["u32"],
                "docs": [" Some number of messages processed."]
              },
              {
                "name": "MessageNotProcessed",
                "args": ["MessageError"],
                "docs": [" Message dispatch resulted in error"]
              }
            ],
            "constants": [
              {
                "name": "SubmitWeightPerByte",
                "type": "u64",
                "value": "0x40420f0000000000",
                "docs": []
              },
              {
                "name": "MessagePerByte",
                "type": "u64",
                "value": "0xa086010000000000",
                "docs": []
              }
            ],
            "errors": [
              {
                "name": "NotEnoughBalanceForReserve",
                "docs": [
                  " Not enough balance to reserve.",
                  "",
                  " Usually occurs when gas_limit specified is such that origin account can't afford the message."
                ]
              }
            ],
            "index": 10
          }
        ],
        "extrinsic": {
          "version": 4,
          "signedExtensions": [
            "CheckSpecVersion",
            "CheckTxVersion",
            "CheckGenesis",
            "CheckMortality",
            "CheckNonce",
            "CheckWeight",
            "ChargeTransactionPayment"
          ]
        }
      }
    }
  }
}
